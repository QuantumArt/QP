# Пользовательские таблицы и представления

## Пользовательские таблицы

### Контентные таблицы

#### Контентные таблицы CONTENT_NNN

Их структура задаётся с помощью UI QP8.CMS. Каждой таблице соответствует одна строка в [таблице CONTENT](main#таблица-content). NNN в названии таблицы – ID записи в этой таблице. Таблица содержит фиксированное количество системных полей, описанных ниже и произвольное количество пользовательских полей. Каждому пользовательскому полю соответствует строка в [таблице CONTENT_ATTRIBUTE](main#таблица-content_attribute). Каждой строке рассматриваемой таблицы соответствует строка в [таблице CONTENT_ITEM](main#таблица-content_item)). Каждой ячейке в рассматриваемой таблице соответствует строка в [таблице CONTENT_DATA](main#таблица-content_data)).

Эти таблицы нельзя редактировать напрямую, вся информация в них заносится триггерами, либо хранимыми процедурами массового копирования.

##### Системные поля

| Имя поля       | Описание |
|----------------|----------|
| CONTENT_ITEM_ID | Уникальный числовой идентификатор. Копируется триггером из поля CONTENT_ITEM_ID таблицы CONTENT_ITEM |
| VISIBLE | Флаг, управляющий показом/скрытием статьи. Копируется триггером из поля VISIBLE таблицы CONTENT_ITEM. |
| STATUS_TYPE_ID | ID статуса статьи по Workflow ([Таблица STATUS_TYPE](extra#таблица-status_type)). Копируется триггером из поля STATUS_TYPE_ID таблицы CONTENT_ITEM. |
| CREATED | Дата создания статьи. Копируется триггером из поля CREATED таблицы CONTENT_ITEM. |
| MODIFIED | Дата последнего изменения статьи. Копируется триггером из поля MODIFIED таблицы CONTENT_ITEM. |
| LAST_MODIFIED_BY | ID последнего пользователя ([Таблица USERS](access#таблица-users)), менявшего свойства статьи. Копируется триггером из поля LAST_MODIFIED_BY таблицы CONTENT_ITEM. |
| ARCHIVE | Флаг, который указывает на то, что статья является архивной. Копируется триггером из поля ARCHIVE таблицы CONTENT_ITEM. |

##### Пользовательские поля

* Каждому пользовательскому полю (колонке контентной таблицы) соответствует запись в таблице CONTENT_ATTRIBUTE ([Таблица CONTENT_ATTRIBUTE](main#таблица-content_attribute)) для текущего контента. Название колонки берется из поля ATTRIBUTE_NAME. Тип данных определяется в соответствии со значением ATTRIBUTE_TYPE_ID колонкой DATABASE_TYPE в таблице ATTRIBUTE_TYPE. Размер данных берется из поля ATTRIBUTE_SIZE. Для NVARCHAR – это максимальная длина строки (по умолчанию – 255). Для NUMERIC – число знаков после запятой (по умолчанию – 0).
* Поля типа Файл или Изображение хранят только название файла, сам файл хранится в файловой системе. Также в некоторых случаях поля типа Файл и Изображение и во всех случаях поле Динамическое изображения хранят относительный путь к файлу (от корня библиотеки или корневой подпапки (SUBFOLDER), если она задана).
* Все типы полей, связанные с датами: Дата, Время, Дата & Время хранятся как DATETIME (совместимость со старыми версиями SQLServer)
* Типы полей Визуальный редактор и Текстовое окно хранятся как NTEXT.
* Поля M2O и М2М не хранят свои данные непосредственно в контентной таблице. Им соответствует тип данных NUMERIC. В контентой таблице они хранят вспомогательные данные. M2M – LINK_ID. M2O – BACK_RELATED_ATTRIBUTE_ID. Это позволяет на основании строки контентной таблицы сразу считывать связанные данные, не прибегая к дополнительным подзапросам.
* Данные M2M хранятся в таблице ITEM_TO_ITEM (альтернативный способ доступа – представление ITEM_LINK)
* Тип данных классификатор построен на числовом типе данных (`ATTRIBUTE_TYPE_ID = 2`). Он отличается установленным флагом `IS_CLASSIFIER = 1`. В таком поле хранится ID контента-расширения (CONTENT_ID), который используется в данной статье.

#### Асинхронные контентные таблицы CONTENT_NNN_ASYNC

Каждой [контентной таблице CONTENT_NNN](#контентные-таблицы-content_nnn) соответствует асинхронная контентная таблица CONTENT_NNN_ASYNC. Структура обеих таблиц совпадает. В последней хранятся текущие версии расщепленных статей (таких записей в [таблице CONTENT_ITEM](main#таблица-content_item), для которых установлено `SPLITTED = 1`)

### Связующие таблицы

#### Связующие таблицы ITEM_LINK_NN

Содержимое данных таблиц формируется на основе информации [таблицы ITEM_TO_ITEM](main#таблица-item_to_item), отфильтрованной по LINK_ID и по прямому направлению связи (l_item_id - это ID статьи из контента L_CONTENT_ID из [таблицы CONTENT_TO_CONTENT](main#таблица-content_to_content))

#### Обратные связующие таблицы ITEM_LINK_NN_REV

Содержимое данных таблиц формируется на основе информации [таблицы ITEM_TO_ITEM](main#таблица-item_to_item), отфильтрованной по LINK_ID и по обратному направлению связи (l_item_id - это ID статьи из контента R_CONTENT_ID из [таблицы CONTENT_TO_CONTENT](main#таблица-content_to_content))

#### Асинхронные связующие таблицы ITEM_LINK_NN_ASYNC

Содержимое данных таблиц формируется на основе информации [таблицы ITEM_LINK_ASYNC](main#таблица-item_link_async), отфильтрованной по LINK_ID и по прямому направлению связи (item_id - это ID статьи из контента L_CONTENT_ID из [таблицы CONTENT_TO_CONTENT](main#таблица-content_to_content))

#### Обратные асинхронные связующие таблицы ITEM_LINK_NN_ASYNC_REV

Содержимое данных таблиц формируется на основе информации [таблицы ITEM_LINK_ASYNC](main#таблица-item_link_async), отфильтрованной по LINK_ID и по обратному направлению связи (linked_item_id - это ID статьи из контента R_CONTENT_ID из [таблицы CONTENT_TO_CONTENT](main#таблица-content_to_content))

### Таблицы плагинов

#### Таблицы плагинов для сайтов PLUGIN_SITE_N

Для каждого плагина с `ID = N` из [таблицы PLUGIN](structure#таблица-plugin) создаётся плоская таблица PLUGIN_SITE_N, в которую переносятся значения из [таблицы PLUGIN_FIELD_VALUE](structure#таблица-plugin_field_value), которые соответствуют полям плагина  из [таблицы PLUGIN_FIELD](structure#таблица-plugin_field) и у которых заполнено поле SITE_ID. В итоге для каждого SITE_ID генерируется своя строчка таблицы PLUGIN_SITE_N.

#### Таблицы плагинов для контентов PLUGIN_CONTENT_N

Для каждого плагина с `ID = N` из [таблицы PLUGIN](structure#таблица-plugin) создаётся плоская таблица PLUGIN_CONTENT_N, в которую переносятся значения из [таблицы PLUGIN_FIELD_VALUE](structure#таблица-plugin_field_value), которые соответствуют полям плагина  из [таблицы PLUGIN_FIELD](structure#таблица-plugin_field) и у которых заполнено поле CONTENT_ID. В итоге для каждого CONTENT_ID генерируется своя строчка таблицы PLUGIN_CONTENT_N.

#### Таблицы плагинов для полей контентов PLUGIN_CONTENT_ATTRIBUTE_N

Для каждого плагина с `ID = N` из [таблицы PLUGIN](structure#таблица-plugin) создаётся плоская таблица PLUGIN_CONTENT_ATTRIBUTE_N, в которую переносятся значения из [таблицы PLUGIN_FIELD_VALUE](structure#таблица-plugin_field_value), которые соответствуют полям плагина  из [таблицы PLUGIN_FIELD](structure#таблица-plugin_field) и у которых заполнено поле CONTENT_ATTRIBUTE_ID. В итоге для каждого CONTENT_ATTRIBUTE_ID генерируется своя строчка таблицы PLUGIN_CONTENT_ATTRIBUTE_N.

## Пользовательские представления

### Пользовательские представления CONTENT_NNN

Строятся для виртуальных контентов. Реализуют запросы в соответствии с типом виртуального контента

### Пользовательские представления CONTENT_NNN_NEW

Данные представления строятся на основе таблиц или представлений CONTENT_NNN, но c преобразованием типов данных в те, которые используются в EF или EF.Core.

### Пользовательские представления CONTENT_NNN_ASYNC_NEW

Данные представления строятся на основе таблиц CONTENT_NNN_ASYNC, но c преобразованием типов данных в те, которые используются в EF или EF.Core.

### Пользовательские представления CONTENT_NNN_LIVE

Данные представления строятся на основе таблиц или представлений CONTENT_NNN, но с применением live-фильтрации по умолчанию. Используются в LINQ-to-SQL.

### Пользовательские представления CONTENT_NNN_LIVE_NEW

Данные представления строятся на основе представлений CONTENT_NNN_LIVE, но c преобразованием типов данных в те, которые используются в EF или EF.Core.

### Пользовательские представления CONTENT_NNN_STAGE

Данные представления строятся на основе таблиц или представлений CONTENT_NNN, но с применением stage-фильтрации по умолчанию. Используются в LINQ-to-SQL.

### Пользовательские представления CONTENT_NNN_STAGE_NEW

Данные представления строятся на основе представления CONTENT_NNN_STAGE, но c преобразованием типов данных в те, которые используются в EF или EF.Core.

### Пользовательские представления CONTENT_NNN_UNITED

Строятся для всех контентов на основе таблиц или представлений CONTENT_NNN и CONTENT_NNN_ASYNC с учётом расщепления статей (если для статья расщеплена, то берётся запись из CONTENT_NNN_ASYNC, иначе из CONTENT_NNN).

### Пользовательские представления CONTENT_NNN_UNITED_NEW

Данные представления строятся на основе представлений CONTENT_NNN_UNITED, но c преобразованием типов данных в те, которые используются в EF или EF.Core.

### Пользовательские представления LINK_NN

Представления, созданные на основе представления ITEM_LINK и отфильтрованные по LINK_ID. Используются в LINQ-to-SQL моделях.

### Пользовательские представления LINK_NN_UNITED

Представления, созданные на основе представления ITEM_LINK_UNITED и отфильтрованные по LINK_ID. Используются в LINQ-to-SQL моделях.

### Пользовательские представления ITEM_LINK_NN_UNITED

Представления, созданные на основе таблиц ITEM_LINK_NN и ITEM_LINK_NN_ASYNC с учётом расщепления статей (если статья c идентификатором из поля ID расщеплена, то берётся запись из ITEM_LINK_NN_ASYNC, иначе из ITEM_LINK_NN)

### Пользовательские представления ITEM_LINK_NN_UNITED_REV

Представления, созданные на основе таблиц ITEM_LINK_NN_REV и ITEM_LINK_NN_ASYNC_REV с учётом расщепления статей (если если статья c идентификатором из поля ID расщеплена, то берётся запись из ITEM_LINK_NN_ASYNC_REV, иначе из ITEM_LINK_NN_REV)
